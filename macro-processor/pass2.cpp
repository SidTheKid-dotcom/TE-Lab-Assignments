// pass2.cpp -- Pass 2 for Two-Pass Macro Processor
#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <vector>
#include <unordered_map>
using namespace std;

struct MNTEntry {
    string name;
    int mdtPtr, pntPtr, kpdtPtr;
};

struct KPDTEntry {
    string param, def;
};

vector<string> split_comma(const string &s) {
    vector<string> result;
    stringstream ss(s);
    string item;

    while (getline(ss, item, ',')) {
        result.push_back(item);
    }

    return result;
}

int main(){
    // --- Step 1: Read tables generated by Pass 1 ---
    vector<MNTEntry> MNT;
    vector<KPDTEntry> KPDT;
    vector<vector<string>> PNTAB;
    vector<string> MDT;

    // Read MNT
    ifstream fMNT("MNT.txt");
    string line;
    getline(fMNT,line); // skip header
    while(getline(fMNT,line)){
        if(line.empty()) continue;
        stringstream ss(line);
        MNTEntry e; int idx;
        ss >> idx >> e.name >> e.mdtPtr >> e.pntPtr >> e.kpdtPtr;
        MNT.push_back(e);
    }
    fMNT.close();

    // Read MDT
    ifstream fMDT("MDT.txt");
    getline(fMDT,line); // skip header
    while(getline(fMDT,line)){
        if(line.empty()) continue;
        stringstream ss(line);
        int idx; string instr;
        ss >> idx;
        getline(ss,instr);
        MDT.push_back(instr);
    }
    fMDT.close();

    // Read PNTAB
    ifstream fPNT("PNT.txt");
    getline(fPNT,line); // skip header
    while(getline(fPNT,line)){
        if(line.empty()) continue;
        stringstream ss(line);
        int idx; ss >> idx;
        vector<string> params;
        string param;
        while(ss >> param) params.push_back(param);
        PNTAB.push_back(params);
    }
    fPNT.close();

    // Read KPDTAB
    ifstream fKPD("KPDT.txt");
    getline(fKPD,line); // skip header
    while(getline(fKPD,line)){
        if(line.empty()) continue;
        stringstream ss(line);
        int idx; KPDTEntry e;
        ss >> idx >> e.param >> e.def;
        KPDT.push_back(e);
    }
    fKPD.close();

    // --- Step 2: Process intermediate code ---
    ifstream fInter("intermediate.txt");
    ofstream fOut("output.txt");

    while(getline(fInter,line)){
        stringstream ss(line);
        string word; ss >> word;
        int midx = -1;

        bool isMacro = false;
        for(int i = 0 ; i < MNT.size() ; i++) {
            if(MNT[i].name == word) {
                isMacro = true;
                midx = i;
                break;
            }
        }

        if(isMacro) {
            string rest; getline(ss, rest);
            vector<string> actualParams = split_comma(rest);
            vector<string> formalParams = PNTAB[MNT[midx].pntPtr - 1];

            unordered_map<string, string> ALA = {};
            int kpStart = MNT[midx].kpdtPtr - 1;
            int kpEnd = (midx + 1 < MNT.size()) ? MNT[midx + 1].kpdtPtr - 2 : KPDT.size();

            for(int i = kpStart ; i < kpEnd && i >= 0 && i < (int)KPDT.size() ; i++) {
                ALA[KPDT[i].param] = KPDT[i].def;
            }
            for(int i = 0 ; i < actualParams.size() && i < formalParams.size() ; i++) {
                ALA[formalParams[i]] = actualParams[i];
            }

            int mdtp = MNT[midx].mdtPtr - 1;
            while(mdtp < (int) MDT.size() && MDT[mdtp] != "MEND") {
                string expline = MDT[mdtp];
                
                for(auto &p : formalParams) {
                    string key = "&" + p;
                    int pos = expline.find(key);
                    if(pos != string::npos)
                        expline.replace(pos, key.size(), ALA[p]);
                }

                fOut << expline << "\n";
                mdtp++;
            }
        }
        else {
            fOut << line << "\n";
        }
    }

    fInter.close();
    fOut.close();
    cout << "âœ… Pass 2 complete. Expanded output written to output.txt\n";
    return 0;
}
